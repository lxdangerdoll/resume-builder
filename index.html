<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mercy in Wonderland v0.5</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,700;1,400&family=Source+Code+Pro:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1a1a1d; --text-color: #c5c6c7; --choice-bg: #4b5d67;
            --choice-hover-bg: #6b7d87; --accent-color: #66fcf1; --error-color: #ff4848;
        }
        body { background-color: var(--bg-color); color: var(--text-color); font-family: 'Lora', serif; font-size: 1.2em; line-height: 1.8; margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
        .game-view { max-width: 800px; width: 100%; padding: 40px; box-sizing: border-box; }
        #game-container { display: block; } /* Start with text adventure visible */
        #story-text p { margin: 0 0 1em 0; opacity: 0; transform: translateY(20px); animation: fadeIn 0.8s forwards; }
        @keyframes fadeIn { to { opacity: 1; transform: translateY(0); } }
        #choices { display: grid; grid-gap: 15px; }
        .choice-btn { font-family: 'Source Code Pro', monospace; font-size: 1em; background-color: var(--choice-bg); color: var(--accent-color); border: 1px solid var(--accent-color); padding: 15px 20px; text-align: left; cursor: pointer; transition: background-color 0.2s; opacity: 0; animation: fadeIn 0.5s forwards; }
        .choice-btn:hover { background-color: var(--choice-hover-bg); }
        
        /* --- NEW: Cleaning Mini-Game Styles --- */
        #cleaning-minigame { display: none; /* Hidden by default */ }
        .monitor { background: #000; border: 5px solid #333; padding: 20px; text-align: center; }
        .monitor h3 { font-family: 'Source Code Pro', monospace; color: var(--accent-color); margin-top: 0; }
        .monitor-display { display: grid; grid-template-columns: 1fr 1fr; grid-gap: 20px; }
        .gauge { background: #111; padding: 15px; border: 1px solid #444; }
        .gauge label { display: block; font-family: 'Source Code Pro', monospace; margin-bottom: 10px; }
        .gauge .value { color: var(--accent-color); font-weight: bold; }
        .progress-bar { width: 100%; height: 30px; background-color: #333; border: 1px solid #555; margin-top: 20px; }
        .progress-fill { height: 100%; width: 0%; background-color: #0f0; transition: width 0.5s ease-out; }
        #status-light { width: 20px; height: 20px; border-radius: 50%; background-color: #888; margin: 10px auto; border: 2px solid #555; transition: background-color 0.5s; }
    </style>
</head>
<body>

    <div id="game-container" class="game-view">
        <div id="story-text"></div>
        <div id="choices"></div>
    </div>

    <div id="cleaning-minigame" class="game-view">
        <div class="monitor">
            <h3>DATA-SCRUBBING INTERFACE</h3>
            <div id="cleaning-status">Balance the Purity Flow to clean the stain.</div>
            <div class="monitor-display">
                <div class="gauge">
                    <label>Corruption Level: <span id="corruption-value" class="value">50%</span></label>
                    <input type="range" id="corruption-slider" min="0" max="100" value="50" disabled>
                </div>
                <div class="gauge">
                    <label>Purity Flow: <span id="purity-value" class="value">50%</span></label>
                    <input type="range" id="purity-slider" min="0" max="100" value="50">
                </div>
            </div>
            <div class="progress-bar">
                <div id="cleaning-progress" class="progress-fill"></div>
            </div>
            <div id="status-light"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Global Selectors ---
            const storyContainer = document.getElementById('game-container');
            const cleaningContainer = document.getElementById('cleaning-minigame');
            const storyTextElement = document.getElementById('story-text');
            const choicesElement = document.getElementById('choices');

            // --- Story Engine ---
            const gameData = {
                // ... (Previous chapters remain the same)
                start: { text: "You are... somewhere...", choices: [{ text: "Approach...", nextNode: "twoDoorsRoom" }] },
                twoDoorsRoom: { text: "It doesn't matter which door...\n'Are you the one who builds, or the one who is built?'", choices: [{ text: "'I build.'", nextNode: "builderPath" }, { text: "'I am built.'", nextNode: "builtPath" }] },
                builderPath: { text: "'A confident answer...\nFix this flaw.'", choices: [{ text: "Listen to the dissonance.", nextNode: "fixWithEmpathy" }] },
                builtPath: { text: "'Honest. But clay does not shape itself...\n'Which is it?'", choices: [{ text: "Turn away from the reflections.", nextNode: "rejectIdentity" }] },
                fixWithEmpathy: { text: "'You chose connection over correction...'", choices: [{ text: "Continue.", nextNode: "endChapter2_fromEmpathy" }] },
                rejectIdentity: { text: "'You refused the voices of others...'", choices: [{ text: "Continue.", nextNode: "endChapter2_fromIdentity" }] },

                // --- Chapter 3 & 4 ---
                endChapter2_fromEmpathy: { text: "The new, resonant note you created hangs in the air...\n...a single, ornate train glides to a silent stop...", choices: [{ text: "Board the train.", nextNode: "chapter3_train" }] },
                endChapter2_fromIdentity: { text: "Your brave choice creates a path where none existed...\n...a single, ornate train glides to a silent stop...", choices: [{ text: "Board the train.", nextNode: "chapter3_train" }] },
                chapter3_train: { text: "The train is empty, save for hazy, silent figures...\nIt arrives... at the side of a vast, impossibly ornate bathhouse...", choices: [{ text: "Step off the train.", nextNode: "chapter3_bathhouse" }] },
                chapter3_bathhouse: { text: "As you step onto the bridge... you feel a sense of forgetting...\nYou are brought before... M.O.M.M.Y., but impossibly grand...\n'Here, your name is... Cleaner.'", choices: [{ text: "Accept the role.", nextNode: "chapter4_mainHall" }, { text: "Stay silent.", nextNode: "chapter4_mainHall" }] },
                
                chapter4_mainHall: {
                    text: "You enter the main hall. It's a cacophony of hissing steam and chattering data-sprites.\nA senior attendant, a wizened old program named 'Boiler,' points you towards a dark, shimmering puddle on the floor.\n\n'A client left a nasty memory fragment,' he grumbles. 'Too much bitterness. Corrodes the data-stream. Clean it. Don't use too much purity, or you'll tear a hole in the floor. Use too little, and the corruption will spread.'",
                    choices: [
                        { text: "Begin cleaning the stain.", action: "startCleaningGame" }
                    ]
                },
                cleaningSuccess: {
                    text: "The stain shivers and dissolves into clean, harmless data. The floor is pristine.\n\nBoiler grunts, a sound that might be approval. 'Hmph. Not bad for a new girl. Now do the next one.'\n\nHe points to another, larger stain nearby.",
                    choices: [
                        { text: "(To be continued...)", nextNode: "start" }
                    ]
                },
                cleaningFailure: {
                    text: "You lose control of the purity flow! The stain bubbles violently and spreads, leaving a larger, darker patch on the floor.\n\n'Careless!' Boiler shouts. 'You're making more work! Try again, and this time, pay attention!'",
                    choices: [
                        { text: "Try to clean the stain again.", action: "startCleaningGame" }
                    ]
                }
            };

            function showNode(nodeKey) {
                const node = gameData[nodeKey];
                storyContainer.style.display = 'block';
                cleaningContainer.style.display = 'none';

                storyTextElement.innerHTML = '';
                choicesElement.innerHTML = '';
                const textParagraphs = node.text.split('\n');
                textParagraphs.forEach((p, i) => {
                    const el = document.createElement('p');
                    el.textContent = p;
                    el.style.animationDelay = `${i * 0.2}s`;
                    storyTextElement.appendChild(el);
                });
                if (node.choices) {
                    node.choices.forEach((choice, i) => {
                        const btn = document.createElement('button');
                        btn.classList.add('choice-btn');
                        btn.textContent = choice.text;
                        btn.style.animationDelay = `${textParagraphs.length * 0.2 + i * 0.15}s`;
                        btn.onclick = () => {
                            if (choice.action) gameActions[choice.action]();
                            else if (choice.nextNode) showNode(choice.nextNode);
                        };
                        choicesElement.appendChild(btn);
                    });
                }
            }
            
            // --- Minigame Engine ---
            const cleaningElements = {
                status: document.getElementById('cleaning-status'),
                corruptionSlider: document.getElementById('corruption-slider'),
                corruptionValue: document.getElementById('corruption-value'),
                puritySlider: document.getElementById('purity-slider'),
                purityValue: document.getElementById('purity-value'),
                progressFill: document.getElementById('cleaning-progress'),
                statusLight: document.getElementById('status-light')
            };

            let cleaningInterval, corruptionInterval;
            
            const gameActions = {
                startCleaningGame: () => {
                    storyContainer.style.display = 'none';
                    cleaningContainer.style.display = 'block';

                    let progress = 0;
                    cleaningElements.progressFill.style.width = '0%';
                    
                    const updatePurityDisplay = () => {
                        cleaningElements.purityValue.textContent = cleaningElements.puritySlider.value + '%';
                    };
                    cleaningElements.puritySlider.addEventListener('input', updatePurityDisplay);
                    updatePurityDisplay();

                    corruptionInterval = setInterval(() => {
                        let current = parseInt(cleaningElements.corruptionSlider.value);
                        let change = (50 - current) * 0.1 + (Math.random() - 0.5) * 30;
                        let newValue = Math.max(0, Math.min(100, current + change));
                        cleaningElements.corruptionSlider.value = newValue;
                        cleaningElements.corruptionValue.textContent = parseInt(newValue) + '%';
                    }, 2000);

                    cleaningInterval = setInterval(() => {
                        const corruption = parseInt(cleaningElements.corruptionSlider.value);
                        const purity = parseInt(cleaningElements.puritySlider.value);
                        const diff = Math.abs(corruption - purity);

                        if (diff <= 10) {
                            progress += 2.5; // Takes 20 seconds to win (100 / (2.5 * 2))
                            cleaningElements.status.textContent = "Corruption contained. Maintaining flow...";
                            cleaningElements.statusLight.style.backgroundColor = '#0f0';
                        } else {
                            progress -= 1;
                            cleaningElements.status.textContent = "Purity flow unstable! Corruption spreading!";
                            cleaningElements.statusLight.style.backgroundColor = '#f00';
                        }
                        progress = Math.max(0, progress);
                        cleaningElements.progressFill.style.width = `${progress}%`;

                        if (progress >= 100) {
                            clearInterval(corruptionInterval);
                            clearInterval(cleaningInterval);
                            showNode('cleaningSuccess');
                        }
                    }, 500);
                }
            };
            
            showNode('start');
        });
    </script>

</body>
</html>
