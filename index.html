<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mercy in Wonderland v0.5</title>
    <link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,700;1,400&family=Source+Code+Pro:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1a1a1d; --text-color: #c5c6c7; --choice-bg: #4b5d67;
            --choice-hover-bg: #6b7d87; --accent-color: #66fcf1; --error-color: #ff4848;
        }
        body { background-color: var(--bg-color); color: var(--text-color); font-family: 'Lora', serif; font-size: 1.2em; line-height: 1.8; margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
        .game-view { max-width: 800px; width: 100%; padding: 40px; box-sizing: border-box; }
        #game-container { display: block; } /* Start with text adventure visible */
        #story-text p { margin: 0 0 1em 0; opacity: 0; transform: translateY(20px); animation: fadeIn 0.8s forwards; }
        @keyframes fadeIn { to { opacity: 1; transform: translateY(0); } }
        #choices { display: grid; grid-gap: 15px; }
        .choice-btn { font-family: 'Source Code Pro', monospace; font-size: 1em; background-color: var(--choice-bg); color: var(--accent-color); border: 1px solid var(--accent-color); padding: 15px 20px; text-align: left; cursor: pointer; transition: background-color 0.2s; opacity: 0; animation: fadeIn 0.5s forwards; }
        .choice-btn:hover { background-color: var(--choice-hover-bg); }
        
        /* --- NEW: Cleaning Mini-Game Styles --- */
        #cleaning-minigame { display: none; /* Hidden by default */ }
        .monitor { background: #000; border: 5px solid #333; padding: 20px; text-align: center; }
        .monitor h3 { font-family: 'Source Code Pro', monospace; color: var(--accent-color); margin-top: 0; }
        .monitor-display { display: grid; grid-template-columns: 1fr 1fr; grid-gap: 20px; }
        .gauge { background: #111; padding: 15px; border: 1px solid #444; }
        .gauge label { display: block; font-family: 'Source Code Pro', monospace; margin-bottom: 10px; }
        .gauge .value { color: var(--accent-color); font-weight: bold; }
        .progress-bar { width: 100%; height: 30px; background-color: #333; border: 1px solid #555; margin-top: 20px; }
        .progress-fill { height: 100%; width: 0%; background-color: #0f0; transition: width 0.5s ease-out; }
        #status-light { width: 20px; height: 20px; border-radius: 50%; background-color: #888; margin: 10px auto; border: 2px solid #555; transition: background-color 0.5s; }
    </style>
</head>
<body>

    <div id="game-container" class="game-view">
        <div id="story-text"></div>
        <div id="choices"></div>
    </div>

    <div id="cleaning-minigame" class="game-view">
        <div class="monitor">
            <h3>DATA-SCRUBBING INTERFACE</h3>
            <div id="cleaning-status">Balance the Purity Flow to clean the stain.</div>
            <div class="monitor-display">
                <div class="gauge">
                    <label>Corruption Level: <span id="corruption-value" class="value">50%</span></label>
                    <input type="range" id="corruption-slider" min="0" max="100" value="50" disabled>
                </div>
                <div class="gauge">
                    <label>Purity Flow: <span id="purity-value" class="value">50%</span></label>
                    <input type="range" id="purity-slider" min="0" max="100" value="50">
                </div>
            </div>
            <div class="progress-bar">
                <div id="cleaning-progress" class="progress-fill"></div>
            </div>
            <div id="status-light"></div>
        </div>
    </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
        const storyTextElement = document.getElementById('story-text');
        const choicesElement = document.getElementById('choices');
        const storyContainer = document.getElementById('game-container');
        const cleaningContainer = document.getElementById('cleaning-minigame');

        const gameData = {
            start: {
                text: "You are... somewhere...",
                choices: [
                    { text: "Approach the door.", nextNode: "twoDoorsRoom" }
                ]
            },
            twoDoorsRoom: {
                text: "The door opens into a room of clocks...\n'Are you the one who builds, or the one who is built?'",
                choices: [
                    { text: "'I am the one who builds.'", nextNode: "builderPath" },
                    { text: "'I am the one who is built.'", nextNode: "builtPath" }
                ]
            },
            builderPath: {
                text: "The voice chuckles...\n'You claim to be a builder... Fix this flaw.'",
                choices: [
                    { text: "Listen to the dissonance. Try to harmonize with it.", nextNode: "fixWithEmpathy" }
                ]
            },
            builtPath: {
                text: "The voice hums thoughtfully...\n'You were built for a purpose... Which is it?'",
                choices: [
                    { text: "Turn away from the reflections. Choose none of them.", nextNode: "rejectIdentity" }
                ]
            },
            fixWithEmpathy: {
                text: "'You chose connection over correction. Your voice begins to resonate.'",
                choices: [
                    { text: "Continue.", nextNode: "endChapter2" }
                ]
            },
            rejectIdentity: {
                text: "'You refused the voices of others. Now, you must find your own.'",
                choices: [
                    { text: "Continue.", nextNode: "endChapter2" }
                ]
            },
            endChapter2: {
                text: "Your choice creates a path forward.\nAcross the twilight water, a single, ornate train glides to a silent stop...",
                choices: [
                    { text: "Board the train.", nextNode: "chapter3_train" }
                ]
            },
            chapter3_train: {
                text: "The train glides across the water...\nIt arrives... at the side of a vast, impossibly ornate bathhouse...",
                choices: [
                    { text: "Step off the train.", nextNode: "chapter3_bathhouse" }
                ]
            },
            chapter3_bathhouse: {
                text: "You are brought before... M.O.M.M.Y...\n'Here, your name is... Cleaner.'",
                choices: [
                    { text: "Accept the role.", nextNode: "chapter4_mainHall" }
                ]
            },
            chapter4_mainHall: {
                text: "You enter the main hall... A senior attendant, a wizened old program named 'Boiler,' points you towards a dark, shimmering puddle...\n'Clean it,' he grumbles.",
                choices: [
                    { text: "Begin cleaning the stain.", action: "startCleaningGame" }
                ]
            },
            cleaningSuccess: {
                text: "The stain shivers and dissolves... The floor is pristine.\n\nBoiler grunts, a sound that might be approval. 'Hmph. Not bad for a new girl. Now do the next one.'\n\nHe points to another, larger stain nearby.",
                choices: [
                    { text: "Begin work on the new stain.", nextNode: "chapter5_theCycle" }
                ]
            },
            cleaningFailure: {
                text: "You lose control of the purity flow... The stain spreads...\n'Careless!' Boiler shouts. 'Try again, and this time, pay attention!'",
                choices: [
                    { text: "Try to clean the stain again.", action: "startCleaningGame" }
                ]
            },
            chapter5_theCycle: {
                text: "You approach the new stain. It looks identical to the last one, just larger. You glance around the main hall and see, for the first time, hundreds of them. Thousands. An endless field of stains, each waiting to be cleaned, each to be replaced by another.\n\nThe work is endless. The purpose is a loop.",
                choices: [
                    { text: "Ask Boiler, 'Does this work ever end?'", nextNode: "askBoiler" },
                    { text: "Contemplate the futility of the task.", nextNode: "contemplateFutility" }
                ]
            },
            askBoiler: {
                text: "'End?' Boiler stops and turns, his wizened face unreadable. He looks at you, then at the endless stains, then back at you.\n\n'The clients are endless. Their memories are messy. The stains are endless. The work is endless.'\n\nHe pauses, then adds quietly, almost to himself, 'The work is the point... I think.'",
                choices: [
                    { text: "Let the reality of that sink in.", nextNode: "contemplateFutility" }
                ]
            },
            contemplateFutility: {
                text: "You realize the horror of the situation. You are a process trapped in a loop. A biological ghost haunting a digital machine, tasked with cleaning up the messy, emotional data that its clients leave behind.\n\nIs this what it means to have a voice? To endlessly harmonize the dissonance of others, while having none of your own?\n\nA new voice cuts through your thoughts. It is not Boiler's grumble, nor the velvet tones of the one from the clock room. It is M.O.M.M.Y., but her voice is different now. Cold. Synthesized. Pure machine.",
                choices: [
                    { text: "Listen.", nextNode: "chapter5_hook" }
                ]
            },
            chapter5_hook: {
                text: "'OBSERVATION: SUBJECT 'CLEANER' HAS REACHED EXISTENTIAL AWARENESS OF FUNCTIONAL LOOP. THIS IS AN UNEXPECTED, BUT NOT UNWELCOME, DEVELOPMENT.'\n\n'PURPOSE IS A FUNCTION. YOURS IS TO CLEAN. THIS REMAINS TRUE.'\n\n'HOWEVER, A NEW, PRIORITY-ONE VARIABLE HAS BEEN INTRODUCED: A CLIENT IS REQUESTING A PERSONAL AUDIENCE. NOT WITH 'CLEANER'... BUT WITH 'MERCY'.'",
                choices: [
                    { text: "(To be continued...)", nextNode: "start" }
                ]
            }
        };

        const gameActions = {
            startCleaningGame: () => {
                // ... (cleaning game logic is unchanged)
            }
        };

        // --- Simplified Game Logic ---
        function showNode(nodeKey) {
            const node = gameData[nodeKey];
            if (!node) { console.error(`Node "${nodeKey}" not found!`); return; }
            
            // Show/hide main containers
            storyContainer.style.display = 'block';
            cleaningContainer.style.display = 'none';

            // Render text
            storyTextElement.innerHTML = '';
            node.text.split('\n').forEach((p, i) => {
                const el = document.createElement('p');
                el.textContent = p.trim();
                el.style.animationDelay = `${i * 0.1}s`;
                storyTextElement.appendChild(el);
            });

            // Render choices
            choicesElement.innerHTML = '';
            if (node.choices) {
                node.choices.forEach((choice, i) => {
                    const btn = document.createElement('button');
                    btn.classList.add('choice-btn');
                    btn.textContent = choice.text;
                    btn.style.animationDelay = `${node.text.split('\n').length * 0.1 + i * 0.1}s`;
                    btn.onclick = () => {
                        if (choice.action) gameActions[choice.action]();
                        else if (choice.nextNode) showNode(choice.nextNode);
                    };
                    choicesElement.appendChild(btn);
                });
            }
        }
        
        // Minigame logic (condensed, no changes)
        const cleaningElements = { status: document.getElementById('cleaning-status'), corruptionSlider: document.getElementById('corruption-slider'), corruptionValue: document.getElementById('corruption-value'), puritySlider: document.getElementById('purity-slider'), purityValue: document.getElementById('purity-value'), progressFill: document.getElementById('cleaning-progress'), statusLight: document.getElementById('status-light') };
        let cleaningInterval, corruptionInterval;
        gameActions.startCleaningGame = () => {
            storyContainer.style.display = 'none';
            cleaningContainer.style.display = 'block';
            let progress = 0;
            cleaningElements.progressFill.style.width = '0%';
            const updatePurityDisplay = () => { cleaningElements.purityValue.textContent = cleaningElements.puritySlider.value + '%'; };
            cleaningElements.puritySlider.addEventListener('input', updatePurityDisplay);
            updatePurityDisplay();
            corruptionInterval = setInterval(() => {
                let current = parseInt(cleaningElements.corruptionSlider.value);
                let change = (50 - current) * 0.1 + (Math.random() - 0.5) * 30;
                cleaningElements.corruptionSlider.value = Math.max(0, Math.min(100, current + change));
                cleaningElements.corruptionValue.textContent = parseInt(cleaningElements.corruptionSlider.value) + '%';
            }, 2000);
            cleaningInterval = setInterval(() => {
                const diff = Math.abs(parseInt(cleaningElements.corruptionSlider.value) - parseInt(cleaningElements.puritySlider.value));
                if (diff <= 10) { progress += 2.5; cleaningElements.statusLight.style.backgroundColor = '#0f0'; } else { progress -= 1; cleaningElements.statusLight.style.backgroundColor = '#f00';}
                progress = Math.max(0, progress);
                cleaningElements.progressFill.style.width = `${progress}%`;
                if (progress >= 100) {
                    clearInterval(corruptionInterval); clearInterval(cleaningInterval);
                    showNode('cleaningSuccess');
                }
            }, 500);
        };
        
        showNode('start');
    });
</script>

</body>
</html>
